#SECURITY NOTE: anything in here can be created simply by sending the 
# class name over the network.  This is a potential vulnerability
# I wouldn't suggest letting any of these classes DO anything, especially
# things like file system access, or allocating huge amounts of memory

import logging
logging.basicConfig()

#------------------------------------------------------------------------------
class EventManager:
    """this object is responsible for coordinating most communication
    between the Model, View, and Controller."""
    def __init__(self):
        from weakref import WeakKeyDictionary
        self.listeners = WeakKeyDictionary()
        self.eventQueue= []
        self.listenersToAdd = []
        self.listenersToRemove = []

    #----------------------------------------------------------------------
    def RegisterListener( self, listener ):
        self.listenersToAdd.append(listener)

    #----------------------------------------------------------------------
    def ActuallyUpdateListeners(self):
        for listener in self.listenersToAdd:
            self.listeners[ listener ] = 1
        for listener in self.listenersToRemove:
            if listener in self.listeners:
                del self.listeners[ listener ]

    #----------------------------------------------------------------------
    def UnregisterListener( self, listener ):
        self.listenersToRemove.append(listener)
        
    #----------------------------------------------------------------------
    def Post( self, event ):
        self.eventQueue.append(event)
        if isinstance(event, Tick):
            # Consume the event queue every Tick.
            self.ActuallyUpdateListeners()
            self.ConsumeEventQueue()
        else:
            logging.debug( "     Message: " + event.name )

    #----------------------------------------------------------------------
    def ConsumeEventQueue(self):
        i = 0
        while i < len( self.eventQueue ):
            event = self.eventQueue[i]
            methodName = 'on' + event.__class__.__name__
            for listener in self.listeners:
                # Note: a side effect of notifying the listener
                # could be that more events are put on the queue
                # or listeners could Register / Unregister
                #listener.notify( event )
                if hasattr(listener, methodName):
                    method = getattr(listener, methodName)
                    method(*event.args, **event.kwargs)
                elif hasattr(listener, 'notify'):
                    method = getattr(listener, 'notify')
                    method(event)
            i += 1
            if self.listenersToAdd:
                self.ActuallyUpdateListeners()
        # all code paths that could possibly add more events to 
        # the eventQueue have been exhausted at this point, so 
        # it's safe to empty the queue
        self.eventQueue = []


_eventManager = EventManager()

def post(arg1, *extraArgs, **kwargs):
    if isinstance(arg1, Event):
        assert not extraArgs
        assert not kwargs
        post_eventObj(arg1)
    else:
        assert isinstance(arg1, str)
        post_stringEvent(arg1, extraArgs, kwargs)

def post_eventObj(ev):
    _eventManager.Post(ev)

def post_stringEvent(arg1, extraArgs, kwargs):
    class AnonymousEvent(Event): pass
    AnonymousEvent.__name__ = arg1
    event = AnonymousEvent()
    event.name = arg1
    event.args = extraArgs
    event.kwargs = kwargs
    _eventManager.Post(event)


def registerListener(listener):
    _eventManager.RegisterListener(listener)


class Event:
    """this is a superclass for any events that might be generated by an
    object and sent to the EventManager"""
    def __init__(self):
        self.name = self.__class__.__name__
        self.args = ()
        self.kwargs = {}
    def __str__(self):
        return '<%s %s>' % (self.name, id(self))
        

class Tick(Event):
    def __init__(self):
        Event.__init__(self)
        self.name = "CPU Tick Event"

class Quit(Event):
    def __init__(self):
        Event.__init__(self)
        self.name = "Program Quit Event"


if __name__ == '__main__':

    class Printer(object):
        def onA(self, foo, bar):
            print 'A'
            post('C')
        def onB(self, foo, bar):
            print 'B'
        def onC(self):
            print 'C'

    class NotifyPrinter(object):
        def notify(self, event):
            print '\t\tNotify event', event

    p = Printer()
    np = NotifyPrinter()
    registerListener(p)
    registerListener(np)

    post(Tick())

    post('A', 'foo', 'bar')

    class B(Event): pass
    evB = B()
    evB.kwargs = dict(foo = 'foo', bar = 'bar')
    post(evB)

    post(Tick())
