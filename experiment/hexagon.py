import math
from math import sin, cos, sqrt
import shutil
import os
import time

inkscape_pt_to_mm = 3.8655


def reasonable(x):
    if -0.0000001 < x < 0.0000001:
        return 0
    return x

# -----------------------------------------------------------------------------
def makedeltas(x=0, y=0, edgesize=100):
    if type(x) in (tuple, list):
        x, y = x
    yield [x,y]
    for i in range(6):
        dx = edgesize * math.cos((i/3.0)*math.pi)
        dy = edgesize * math.sin((i/3.0)*math.pi)
        dx = reasonable(dx)
        dy = reasonable(dy)
        yield [dx,dy]


svgID = 1

# -----------------------------------------------------------------------------
class Hex(object):
    edgesize = 42.5
    def __init__(self, xy=(0,0), center=None, edgesize=None):
        self.xy = xy
        if edgesize == None:
            self.edgesize = Hex.edgesize
        else:
            self.edgesize = edgesize

        self.edgecolor = '000000'
        self.fillcolor = 'ffffff'

        global svgID
        self.pathname = 'genpath' + str(svgID)
        svgID += 1
        if center:
            assert xy == (0,0)
            self.center = center

    def __str__(self):
        return '<Hex %s %s>' % (self.xy, self.edgesize)

    # -------------------------------------------------------------------------
    def getWidth(self):
        r'''
               --------
              /        \
             /          \
            /            \
           /..............\
           \    width     /
            \            /
             \          /
              \        /
               --------
        '''
        return self.edgesize * 2
    width = property(getWidth)

    # -------------------------------------------------------------------------
    def getCenterToEdgeNormal(self):
        r'''
               --------
              /    |   \
             /    A|    \
            /      |     \
           /       |......\
           \          B   /
            \            /
             \          /
              \        /
               --------
        center to edge normal = A
        '''
        return self.edgesize * math.sin((1/3.0)*math.pi)
    centerToEdgeNormal = property(getCenterToEdgeNormal)
    hh = centerToEdgeNormal # "hh" = "half height"

    # -------------------------------------------------------------------------
    def getCenterToCorner(self):
        r'''
               --------
              /    |   \
             /    A|    \
            /      |     \
           /       |......\
           \          B   /
            \            /
             \          /
              \        /
               --------
        center to corner = B
        '''
        return self.edgesize * math.cos((1/3.0)*math.pi) + (self.edgesize/2.0)
    centerToCorner = property(getCenterToCorner)
    hw = centerToCorner # "hw" = "half width"

    # -------------------------------------------------------------------------
    def getCenter(self):
        x,y = self.xy
        dx = self.edgesize/2.0
        dy = self.centerToEdgeNormal
        return (x+dx, y+dy)

    def setCenter(self, x=0, y=0):
        if type(x) in (tuple, list):
            x, y = x

        # the delta of travelling from the center to the topleft
        dx = -(self.edgesize/2.0)
        dy = -self.centerToEdgeNormal
        self.xy = (x+dx, y+dy)
    center = property(getCenter, setCenter)

    # -------------------------------------------------------------------------
    def getCenterX(self):
        return self.center[0]
    def setCenterX(self, x):
        self.center = x, self.center[1]
    centerX = property(getCenterX, setCenterX)

    # -------------------------------------------------------------------------
    def getCenterY(self):
        return self.center[1]
    def setCenterY(self, y):
        self.center = self.center[0], y
    centerY = property(getCenterY, setCenterY)

    # -------------------------------------------------------------------------
    def getDeltaGenerator(self):
        return makedeltas(*self.xy, edgesize=self.edgesize)
    deltaGen = property(getDeltaGenerator)

    # -------------------------------------------------------------------------
    def topy(self):
        s = [(d[0],d[1]) for d in self.deltaGen]
        s = '%s\n' % s
        return s

    # -------------------------------------------------------------------------
    def tosvg(self):
        s = ''
        for x,y in self.deltaGen:
            x *= inkscape_pt_to_mm
            y *= inkscape_pt_to_mm
            s += ' %s,%s' % (x,y)
        #style="fill:#ffffff;fill-opacity:1;
        #stroke:#000000;stroke-width:1;
        #stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
        subs = dict(points=s)
        subs.update(self.__dict__)
        return '''<path
               id="%(pathname)s"
               style="fill:#%(fillcolor)s;stroke:#%(edgecolor)s;stroke-width:1"
               d="m %(points)s
               z" />
               ''' % subs
               #''' % dict(pathname=self.pathname, edgecolor=self.edgecolor,
                      #points=s)

# -----------------------------------------------------------------------------
def prin():
    for x,y in makedeltas():
        print ','.join([str(a) for a in [x,y]])

# -----------------------------------------------------------------------------
def hexgrid(rows=5,cols=5):
    for i in range(rows):
        for j in range(cols):
            h = Hex()
            yAdjust = (j%2)*h.hh
            h.center = (j*1.5*h.edgesize, 2*i*h.hh + yAdjust)
            yield h

# -----------------------------------------------------------------------------
def hexOnion(layers=1, center=(0,0)):
    h = Hex(center=center)
    yield h
    for i in range(layers):
        #d = (i+1) * 2 * h.hh
        for j in range(0,(i+1)*6):
            if i%2 and j%2:
                d = ((i+1) * h.hw) + (i * h.edgesize)
            else:
                d = (i+1) * 2 * h.hh
            dx = d * math.sin((j/((i+1)*3.0))*math.pi)
            dy = d * math.cos((j/((i+1)*3.0))*math.pi)
            dx = reasonable(dx)
            dy = reasonable(dy)
            h1 = Hex()
            #print 'moving %s by x%s y%s' % (h1, dx, dy)
            h1.centerX = h.centerX + dx
            h1.centerY = h.centerY + dy
            print '%s' % h1
            yield h1

# -----------------------------------------------------------------------------
def hexMega(layers=2):
    h = Hex()
    yield h
    for i in range(layers):
        #d = (i+1) * 2 * h.hh
        for j in range(0,(i+1)*6):
            if i%2 and j%2:
                d = (i * 2 * h.edgesize) + (i*2 * h.edgesize)
            else:
                d = (i+1) * 2 * h.hh
            dx = d * math.sin((j/((i+1)*3.0))*math.pi)
            dy = d * math.cos((j/((i+1)*3.0))*math.pi)
            dx = reasonable(dx)
            dy = reasonable(dy)
            h1 = Hex()
            print 'moving %s by x%s y%s' % (h1, dx, dy)
            h1.centerX = h.centerX + dx
            h1.centerY = h.centerY + dy
            print '%s' % h1
            yield h1

# -----------------------------------------------------------------------------
def hexPlosion(layers=2):
    h = Hex()
    yield h
    for i in range(layers):
        d = (i+1) * 2 * h.hh
        for j in range(0,(i+1)*6):
            dx = d * math.sin((j/((i+1)*3.0))*math.pi)
            dy = d * math.cos((j/((i+1)*3.0))*math.pi)
            #dx = reasonable(dx)
            #dy = reasonable(dy)
            h1 = Hex()
            print 'moving %s by x%s y%s' % (h1, dx, dy)
            h1.centerX = h.centerX + dx
            h1.centerY = h.centerY + dy
            print '%s' % h1
            yield h1

# -----------------------------------------------------------------------------
def hexFlower(layers=1):
    h = Hex()
    yield h
    for i in range(layers):
        d = (i+1) * 2 * h.hh
        for j in range(6):
            dx = d * math.cos((j/3.0)*math.pi)
            dy = d * math.sin((j/3.0)*math.pi)
            dx = reasonable(dx)
            dy = reasonable(dy)
            h1 = Hex()
            print 'moving %s by x%s y%s' % (h1, dx, dy)
            h1.centerX = h.centerX + dx
            h1.centerY = h.centerY + dy
            print '%s' % h1
            yield h1

# -----------------------------------------------------------------------------
def distance(p1, p2):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    return sqrt( dx**2 + dy**2 )

# -----------------------------------------------------------------------------
def direction_vector(p1, p2, scale=1.0):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    hyp_len = distance(p1,p2)
    if hyp_len == 0:
        return [0,0]
    mult = scale / hyp_len
    return vector_scalar_mult((dx,dy), mult)

# -----------------------------------------------------------------------------
def direction_vector_and_distance(p1, p2, scale=1.0):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    hyp_len = sqrt( dx**2 + dy**2 )
    if hyp_len == 0:
        return ([0,0], 0)
    mult = scale / hyp_len
    return (vector_scalar_mult((dx,dy), mult), hyp_len)

# -----------------------------------------------------------------------------
def vector_scalar_mult(v, s):
    return (v[0]*s, v[1]*s)

# -----------------------------------------------------------------------------
def vector_add(v1, v2):
    return v1[0]+v2[0], v1[1]+v2[1]

def makeColorInHexadecimal_1(h):
    dist = distance(h.center, (600,600))
    i = int(((1+sin(dist))/2)*255)
    print i,
    numpart = hex(i).split('x')[1]
    print numpart
    return ('% 2s' % numpart).replace(' ', '0')

def makeColorInHexadecimal_2(h):
    dist = distance(h.center, (600,600))
    dist /= 2.0
    i = int(((1+sin(dist))/2)*255)
    print i,
    numpart = hex(i).split('x')[1]
    print numpart
    return ('% 2s' % numpart).replace(' ', '0')

def makeColorInHexadecimal_3(h):
    dist = distance(h.center, (350,300))
    dist /= 20.0
    between0and1 = (1+sin(dist))/2.0
    print between0and1
    i = int(between0and1*255)
    print i,
    numpart = hex(i).split('x')[1]
    print numpart
    return ('% 2s' % numpart).replace(' ', '0')

SIN_ORIGIN = (350,260)
def sin_intensity(pos):
    dist = distance(pos, SIN_ORIGIN)
    dist /= 20.0
    between0and1 = (1+sin(dist))/2.0
    return between0and1

def makeColorInHexadecimal_4(h):
    dist = distance(h.center, (600,600))
    dist /= 200.0
    between0and1 = (1+sin(dist))/2.0
    i = int(between0and1*255)
    print i,
    numpart = hex(i).split('x')[1]
    print numpart
    return ('% 2s' % numpart).replace(' ', '0')


def draw():
    #h = Hex((0,0))
    #h.center = (0,0)
    #s += h.tosvg()
    #h.setCenter(0,h.hh*2)
    #s += h.tosvg()
    #h.setCenter(0,h.hh*4)
    #s += h.tosvg()
    #h2 = Hex()
    #h2.center = (0,0)
    #h2.centerX += 1.5*h2.edgesize
    #h2.centerY += h2.hh
    #s += h2.tosvg()
    Hex.edgesize=10
    #for h in hexgrid(30,50):
        #blue = makeColorInHexadecimal_3(h)
        #color = 'ffff' + blue
        #h.fillcolor = color
        #s += h.tosvg()
    #for h in hexgrid(30,50):
    return hexOnion(2)
    #for h in hexFlower(2):
        #s += h.tosvg()
        #bzone = sin_intensity(h.center)
        #numInternalHexes = int(bzone * 5)
        #print 'numInternalHexes', numInternalHexes
        #hi = Hex()
        #hi.edgesize = h.edgesize - 2*(numInternalHexes)
        #hi.edgesize = h.edgesize - 2*(1+bzone)
        #hi.center = h.center
        #yield hi
        #if numInternalHexes == 0:
            #s += h.tosvg()
            #
        #for i in range(numInternalHexes):
            #hi = Hex()
            #hi.edgesize = h.edgesize - 2*(i+1)
            #hi.center = h.center
            #s += hi.tosvg()

def writePy():
    fname = 'hexagons.out.py'
    if os.path.exists(fname):
        tstamp = str(time.time())
        bakFname = '/tmp/hexagons.out.py.'+tstamp
        shutil.copy(fname, bakFname)

    meat = ','.join([h.topy() for h in draw()])
    fp = file(fname, 'w')
    fp.write('[' + meat + ']\n')
    fp.close()

def writeSVG():
    fname = 'hexagons.svg'
    if os.path.exists(fname):
        tstamp = str(time.time())
        bakFname = '/tmp/hexagons.svg.'+tstamp
        shutil.copy(fname, bakFname)
    fp = file(fname, 'w')
    meat = ''.join([h.tosvg() for h in draw()])
    fp.write('''\
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="744.09448819"
   height="1052.3622047"
   id="svg2"
   version="1.1"
   inkscape:version="0.47 r22583"
   >
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.70998174"
     inkscape:cx="336.79831"
     inkscape:cy="990.30753"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1280"
     inkscape:window-height="745"
     inkscape:window-x="0"
     inkscape:window-y="36"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1">
    <path
       style="fill:#ff00ff;fill-opacity:1;stroke:#000000;stroke-width:3;stroke-miterlimit:4;stroke-opacity:1"
       d="m 200,0    -90,0 -43,-75 43,-75    87,0 43,75 -43,75 z"
       id="mainhex" />

    <!-- ======================================== -->
    ''' + meat + '''
    <!-- ======================================== -->
  </g>

</svg>
''')
    fp.close()

if __name__ == '__main__':
    writeSVG()
