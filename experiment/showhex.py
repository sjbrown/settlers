#! /usr/bin/env python

import os
import sys
import time
import string
from math import cos, sin, pi

import hexagon

import pygame
import pygame.sprite
from pygame.locals import * #the KeyboardController needs these

import events
#from pygame_utils import *

tileGroup = pygame.sprite.RenderUpdates()
tileModelToSprite = {}
hudGroup = pygame.sprite.RenderUpdates()

white = (255,255,255)
black = (0,0,0)

#------------------------------------------------------------------------------
class CPUSpinnerController:
    def __init__(self):
        events.registerListener( self )
        self.keepGoing = 1

    def run(self):
        self.lastTick = time.time()
        while self.keepGoing:
            now = time.time()
            delta = now - self.lastTick
            self.lastTick = now
            events.post("Tick", delta)

    def onQuit(self):
        #this will stop the while loop from running
        self.keepGoing = False

#------------------------------------------------------------------------------
class FileWatcherController:
    fpath = 'hexagons.out.py'
    def __init__(self):
        events.registerListener( self )
        self.lastMTime = None

    def onTick(self, *args):
        #Handle Input Events
        mtime = os.path.getmtime(self.fpath)
        if mtime != self.lastMTime:
            events.post('FileChanged', self.fpath)
        self.lastMTime = mtime


#------------------------------------------------------------------------------
class KeyboardController:
    """KeyboardController takes Pygame events generated by the
    keyboard and uses them to control the model, by sending Requests
    or to control the Pygame display directly, as with the QuitEvent
    """
    def __init__(self):
        events.registerListener( self )

    def onTick(self, *args):
        #Handle Input Events
        for event in pygame.event.get():
            ev = None
            if event.type == QUIT:
                ev = events.Quit()
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    # Hit Shift-ESC or Ctrl-ESC to go to the debugger
                    # otherwise ESC will quit the game
                    if event.mod and (
                       event.mod & KMOD_SHIFT or event.mod & KMOD_CTRL):
                        print 'event mod', event.mod
                        import pdb
                        pdb.set_trace()
                    else:
                        ev = events.Quit()
                else:
                    ev = ('KeyDown', event.key, event.unicode, event.mod)
            elif event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    events.post('MouseLeftDown', pos=event.pos)
            elif event.type == MOUSEBUTTONUP:
                if event.button == 1:
                    events.post('MouseLeftUp', pos=event.pos)
            elif event.type == MOUSEMOTION:
                events.post('MouseMotion', pos=event.pos, buttons=event.buttons)
            if ev:
                if isinstance(ev, tuple):
                    events.post( *ev )
                else:
                    events.post( ev )

def drawAALineHexTuple(h, surface, color=white):
    aaline = pygame.draw.aaline
    start = h[0]
    for delta in h[1:]:
        p1 = start
        p2 = [start[0]+delta[0], start[1]+delta[1]]
        aaline(surface, color, p1, p2)
        start = p2[:]

def drawAALineHex(h, surface, color=white):
    aaline = pygame.draw.aaline
    gen = h.deltaGen
    start = gen.next()
    for delta in gen:
        p1 = start
        p2 = [start[0]+delta[0], start[1]+delta[1]]
        aaline(surface, color, p1, p2)
        start = p2[:]

#------------------------------------------------------------------------------
class Brush(object):
    timer = 0

class GrowHexBrush(Brush):
    timer = 0
    def __init__(self):
        events.registerListener(self)
        self.hexes = []
        self.newHex = None

    def hexUpdate(self):
        now = time.time()
        dur = now - self.timer
        dur *= 5
        c = self.newHex.center[:]
        self.newHex.edgesize = dur
        self.newHex.center = c

    def onMouseLeftDown(self, pos):
        print 'mousedown'
        self.newHex = hexagon.Hex()
        self.newHex.center = pos
        self.hexes.append(self.newHex)
        self.timer = time.time()

    def onTick(self, *args):
        if self.newHex:
            self.hexUpdate()

    def onMouseLeftUp(self, pos):
        if not self.newHex:
            return
        self.hexUpdate()
        self.timer = 0
        self.newHex = None
    
class ClusterSinBrush(Brush):
    timer = 0
    def __init__(self):
        events.registerListener(self)
        self.hexes = []
        self.newHexes = None
        self.origPos = None
        self.origEdgesize = None

    def hexUpdate(self):
        now = time.time()
        dur = now - self.timer
        mousePos = pygame.mouse.get_pos()
        xDelta = self.origPos[0] - mousePos[0]
        xDelta %= 100 # moving the mouse 100 pixels out is the max
        xMod = xDelta / 100.0 # should now be between 0 and 1
        print 'xd', xDelta

        yDelta = self.origPos[1] - mousePos[1]
        yDelta %= 100 # moving the mouse 100 pixels out is the max
        yMod = yDelta / 50.0 # should now be between 0 and 2
        for h in self.newHexes:
            c = h.center
            dist = hexagon.distance(h.center, self.origPos)
            between0and1 = (1+sin(dist+yMod*pi))/2.0
            modifier = (between0and1 + xMod) % 2
            h.edgesize = self.origEdgesize * modifier
            h.center = c

    def onMouseLeftDown(self, pos):
        print 'mousedown'
        self.origPos = list(pos)
        self.newHexes = list(hexagon.hexOnion(2, pos))
        self.origEdgesize = self.newHexes[0].edgesize
        self.hexes += self.newHexes
        self.timer = time.time()

    def onTick(self, *args):
        if self.newHexes:
            self.hexUpdate()

    def onMouseLeftUp(self, pos):
        if not self.newHexes:
            return
        self.hexUpdate()
        self.timer = 0
        self.newHexes = None
        self.origPos = None
        self.origEdgesize = None
    
#------------------------------------------------------------------------------
class PygameView:
    def __init__(self):
        events.registerListener( self )

        pygame.init()
        self.window = pygame.display.set_mode( (800,740) )
        pygame.display.set_caption( 'TITLE HERE' )

        self.framesPerSec = 30 
        self.countdown = 1.0/self.framesPerSec

        self.background = pygame.Surface( self.window.get_size() )
        self.background.fill(black)

        self.window.blit( self.background, (0,0) )
        pygame.display.flip()

        #self.brush = GrowHexBrush()
        self.brush = ClusterSinBrush()

        self.showHud()

    #----------------------------------------------------------------------
    def showHud(self):
        pass

    #----------------------------------------------------------------------
    def showMap(self):
        #print 'showing map'

        fp = open('hexagons.out.py')
        hexes = eval(fp.read())
        fp.close()
        #hexes = []
        #execfile('hexagons.out.py')

        for hTup in hexes:
            drawAALineHexTuple(hTup, self.background)
            
    #----------------------------------------------------------------------
    def showBrush(self):
        red = (255,5,5)

        for h in self.brush.hexes:
            drawAALineHex(h, self.window, color=red)
            
    #----------------------------------------------------------------------
    def drawCursor(self):
        if not self.showRobberCursor:
            return []
        pos = pygame.mouse.get_pos()
        textImg = font_render('X', color=white, size=36)
        self.window.blit( textImg, vect_diff(pos, (-2,-2)) )
        textImg = font_render('X', color=black, size=36)
        self.window.blit( textImg, pos )
        return [textImg.get_rect().move(pos)]

    #----------------------------------------------------------------------
    def draw(self):
        # clear the screen first
        self.background.fill(black)
        # Draw the whole ocean of hexes...
        #self.showMap()
        self.window.blit( self.background, (0,0) )

        self.showBrush()

        for hudSprite in hudGroup:
            #print 'calling update on ', hudSprite
            hudSprite.update()
        dirtyRects = hudGroup.draw( self.window )

        #dirtyRects += self.drawCursor()

        pygame.display.flip()

    #----------------------------------------------------------------------
    def onFileChanged(self, fpath):
        self.showMap()

    #----------------------------------------------------------------------
    def onTick(self, delta):
        self.countdown -= delta
        if self.countdown <= 0:
            self.countdown = 1.0/self.framesPerSec
            self.draw()

#------------------------------------------------------------------------------
def main():
    spinner = CPUSpinnerController()
    kbController = KeyboardController()
    fwController = FileWatcherController()
    pygameView = PygameView()
    spinner.run()

#------------------------------------------------------------------------------
_oldExceptHook = sys.excepthook
def customExceptHook(etype, evalue, etb):
    print '='*60
    print 'EXCEPTION HOOK'
    _oldExceptHook(etype, evalue, etb)
    import pdb
    retval = pdb.pm()
    print 'retval :', retval
    

if __name__ == "__main__":
    sys.excepthook = customExceptHook
    main()
