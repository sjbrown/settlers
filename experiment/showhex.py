#! /usr/bin/env python

import os
import sys
import time
import string

import pygame
import pygame.sprite
from pygame.locals import * #the KeyboardController needs these

import events
from pygame_utils import *

tileGroup = pygame.sprite.RenderUpdates()
tileModelToSprite = {}
hudGroup = pygame.sprite.RenderUpdates()

#------------------------------------------------------------------------------
class CPUSpinnerController:
    def __init__(self):
        events.registerListener( self )
        self.keepGoing = 1

    def run(self):
        self.lastTick = time.time()
        while self.keepGoing:
            now = time.time()
            delta = now - self.lastTick
            self.lastTick = now
            events.post("Tick", delta)

    def onQuit(self):
        #this will stop the while loop from running
        self.keepGoing = False

#------------------------------------------------------------------------------
class FileWatcherController:
    fpath = 'hexagons.out.py'
    def __init__(self):
        events.registerListener( self )
        self.lastMTime = None

    def onTick(self, *args):
        #Handle Input Events
        mtime = os.path.getmtime(self.fpath)
        if mtime != self.lastMTime:
            events.post('FileChanged', self.fpath)
        self.lastMTime = mtime


#------------------------------------------------------------------------------
class KeyboardController:
    """KeyboardController takes Pygame events generated by the
    keyboard and uses them to control the model, by sending Requests
    or to control the Pygame display directly, as with the QuitEvent
    """
    def __init__(self):
        events.registerListener( self )

    def onTick(self, *args):
        #Handle Input Events
        for event in pygame.event.get():
            ev = None
            if event.type == QUIT:
                ev = events.Quit()
            elif event.type == KEYDOWN:
                if event.key == K_ESCAPE:
                    # Hit Shift-ESC or Ctrl-ESC to go to the debugger
                    # otherwise ESC will quit the game
                    if event.mod and (
                       event.mod & KMOD_SHIFT or event.mod & KMOD_CTRL):
                        print 'event mod', event.mod
                        import pdb
                        pdb.set_trace()
                    else:
                        ev = events.Quit()
                else:
                    ev = ('KeyDown', event.key, event.unicode, event.mod)
            elif event.type == MOUSEBUTTONDOWN:
                if event.button == 1:
                    events.post('MouseLeftDown', pos=event.pos)
            elif event.type == MOUSEBUTTONUP:
                if event.button == 1:
                    events.post('MouseLeftUp', pos=event.pos)
            elif event.type == MOUSEMOTION:
                events.post('MouseMotion', pos=event.pos, buttons=event.buttons)
            if ev:
                if isinstance(ev, tuple):
                    events.post( *ev )
                else:
                    events.post( ev )


#------------------------------------------------------------------------------
class PygameView:
    def __init__(self):
        events.registerListener( self )

        pygame.init()
        self.window = pygame.display.set_mode( (800,740) )
        pygame.display.set_caption( 'TITLE HERE' )

        self.framesPerSec = 10
        self.countDown = 1.0/self.framesPerSec

        self.background = pygame.Surface( self.window.get_size() )
        self.background.fill(black)

        self.window.blit( self.background, (0,0) )
        pygame.display.flip()

        self.showHud()

    #----------------------------------------------------------------------
    def showHud(self):
        pass

    #----------------------------------------------------------------------
    def showMap(self, board):
        # clear the screen first
        self.background.fill(black)
        self.window.blit( self.background, (0,0) )
        pygame.display.flip()

        hexes = []
        execfile('hexagons.out.py')

        center = self.window.get_rect().center

        for h in hexes:
            tSprite = Tile(t)
            x = 300 + tSprite.tile.graphicalPosition[0]*75
            # minus because pygame uses less = up in the y dimension
            y = 300 - tSprite.tile.graphicalPosition[1]*55
            tSprite.rect.move_ip(x,y)
            
    #----------------------------------------------------------------------
    def drawCursor(self):
        if not self.showRobberCursor:
            return []
        pos = pygame.mouse.get_pos()
        textImg = font_render('X', color=white, size=36)
        self.window.blit( textImg, vect_diff(pos, (-2,-2)) )
        textImg = font_render('X', color=black, size=36)
        self.window.blit( textImg, pos )
        return [textImg.get_rect().move(pos)]

    #----------------------------------------------------------------------
    def draw(self):
        self.window.blit( self.background, (0,0) )

        for tSprite in tileGroup:
            tSprite.update()
        dirtyRects = tileGroup.draw( self.window )

        for hudSprite in hudGroup:
            #print 'calling update on ', hudSprite
            hudSprite.update()
        dirtyRects = hudGroup.draw( self.window )

        dirtyRects += self.drawCursor()

        pygame.display.flip()

    #----------------------------------------------------------------------
    def onFileChanged(self, fpath):
        self.showMap()

    #----------------------------------------------------------------------
    def onTick(self, delta):
        self.countdown -= delta
        if self.countdown <= 0:
            self.countDown = 1.0/self.framesPerSec
            self.draw()

#------------------------------------------------------------------------------
def main():
    spinner = CPUSpinnerController()
    kbController = KeyboardController()
    fwController = FileWatcherController()
    pygameView = PygameView()
    spinner.run()

#------------------------------------------------------------------------------
_oldExceptHook = sys.excepthook
def customExceptHook(etype, evalue, etb):
    print '='*60
    print 'EXCEPTION HOOK'
    _oldExceptHook(etype, evalue, etb)
    import pdb
    retval = pdb.pm()
    print 'retval :', retval
    

if __name__ == "__main__":
    sys.excepthook = customExceptHook
    main()
